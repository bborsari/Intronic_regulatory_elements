---
title: "Comparing all ccREs vs. cell-type specific ccREs."
author: "Beatrice Borsari"
date: "October 2019"
output: html_document
---





## No requirement for distance from annotated TSSs

```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, fig.width = 20, fig.height = 5}


#*****************
# LOAD LIBRARIES *
#*****************

.libPaths("/nfs/users2/rg/bborsari/software/R-3.5.2/library")

library(ggplot2)
library(cowplot)
library(ggpubr)



#************
# FUNCTIONS *
#************

map.pvals <- function(x){
  
  if (x < 0.001) {
    
    pval = "***"
    
  } else if (x < 0.01) {
    
    pval = "**"
    
  } else if (x < 0.05) {
    
    pval = "*"
     
  } else {
    
    pval = "ns"
    
  }
  
  return(pval)
  
}


my.function <- function(i) {
  
  lop <- list()
  k=1
  for (j in c(i, i+3, i+6, i+9)) {
    
    sub.m <- m[j:(j+2), ]
    
    # # 1. compute p-values and OR of Fisher test
    # 
    # pvals <- c()
    # OR <- c()
    # 
    # ## 1.1 non.cell_line vs. also.cell_line
    # m2 <- matrix(c(sub.m[sub.m$V3=="non.cell_line", "V1"],
    #                (sub.m[sub.m$V3=="non.cell_line", "V2"] - sub.m[sub.m$V3=="non.cell_line", "V1"]),
    #                sub.m[sub.m$V3=="also.cell_line", "V1"],
    #                (sub.m[sub.m$V3=="also.cell_line", "V2"] - sub.m[sub.m$V3=="also.cell_line", "V1"])),
    #              byrow = T, nrow = 2)
    # 
    # my.test <- fisher.test(m2)
    # pvals <- c(pvals, my.test$p.value)
    # OR <- c(OR, my.test$estimate)
    # 
    # 
    # ## 1.2 also.cell_line vs. cell_line.only
    # m2 <- matrix(c(sub.m[sub.m$V3=="also.cell_line", "V1"],
    #               (sub.m[sub.m$V3=="also.cell_line", "V2"] - sub.m[sub.m$V3=="also.cell_line", "V1"]),
    #               sub.m[sub.m$V3=="cell_line.only", "V1"],
    #               (sub.m[sub.m$V3=="cell_line.only", "V2"] - sub.m[sub.m$V3=="cell_line.only", "V1"])),
    #             byrow = T, nrow = 2)
    # 
    # my.test <- fisher.test(m2)
    # pvals <- c(pvals, my.test$p.value)
    # OR <- c(OR, my.test$estimate)
    # 
    # 
    # ## 1.3 non.cell_line vs. cell_line.only
    # m2 <- matrix(c(sub.m[sub.m$V3=="non.cell_line", "V1"],
    #               (sub.m[sub.m$V3=="non.cell_line", "V2"] - sub.m[sub.m$V3=="non.cell_line", "V1"]),
    #               sub.m[sub.m$V3=="cell_line.only", "V1"],
    #               (sub.m[sub.m$V3=="cell_line.only", "V2"] - sub.m[sub.m$V3=="cell_line.only", "V1"])),
    #             byrow = T, nrow = 2)
    # 
    # my.test <- fisher.test(m2)
    # pvals <- c(pvals, my.test$p.value)
    # OR <- c(OR, my.test$estimate)
    # 
    # 
    # # 2. generate m with results from Fisher test
    # Fisher.res <- data.frame(pvals = pvals,
    #                          OR = OR,
    #                          combinations = c("non.cell_line vs. also.cell_line",
    #                                           "also.cell_line vs. cell_line.only",
    #                                           "non.cell_line vs. cell_line.only"))
    # 
    # Fisher.res$label <- sapply(Fisher.res$pvals, map.pvals)
    # Fisher.res$xmin <- c(1, 2, 1)
    # Fisher.res$xmax <- c(2, 3, 3)
    # Fisher.res$y_pos <- c(80, 90, 100)
    
    #print(Fisher.res)
    
    my.title = paste(m[j, "V5"], m[j, "V6"], sep = "\n")
    lop[[k]] <- ggplot(sub.m, aes(x=V3, y=V4*100, fill=V3)) +
      labs(title = my.title) #+
      # geom_bracket(
      #   xmin = as.numeric(Fisher.res$xmin),
      #   xmax = as.numeric(Fisher.res$xmax),
      #   y.position = as.numeric(Fisher.res$y_pos),
      #   label = Fisher.res$label,
      #   tip.length = 0.05,
      #   inherit.aes = F,
      #   label.size = 7
      # )
    k <- k+1
    
  }
  
  lop <- lapply(lop, function(x) {x <- x +   
    geom_bar(stat="identity", width = .7, color = "black") +
    scale_fill_manual(values = c("#fed976", "#74c476", "#9e9ac8")) +
    guides(fill = F) +
    theme_bw() +
    ylim(0, 100) +
    ylab("% of REs intersecting introns") +
    theme(panel.border = element_blank(), 
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          plot.title = element_text(hjust = .5, size = 15),
          axis.line = element_line(colour = "black"),
          axis.title.x = element_blank(),
          axis.title.y = element_blank(),
          axis.ticks.x = element_blank(),
          axis.text.y = element_text(size = 15),
          axis.text.x = element_blank())})
  plot(plot_grid(plotlist = lop, nrow = 1))
  
   
}

m <- read.table("~/public_html/enhancers_neural_development/ccREs/all.results.txt", h=F, sep="\t",
                stringsAsFactors = F)
m <- m[order(m$V6), ]

m$V3 <- factor(m$V3, levels = c("non.cell_line", "also.cell_line", "cell_line.only"))


my.vector <- seq(1, 378, by = 12)



for ( k in my.vector ) {
  
  cat(paste(unique(m[k:(k+12), "V5"])[1],
          unique(m[k:(k+12), "V5"])[2],
          unique(m[k:(k+12), "V5"])[3],
          unique(m[k:(k+12), "V5"])[4],
          sep = ", "))
  
  my.function(i=k)
  
}

# my.function(i=my.vector[1])
# 
# my.function(i=my.vector[2])
# 
# my.function(i=my.vector[3])
# 
# my.function(i=my.vector[4])
# 
# my.function(i=my.vector[5])
# 
# my.function(i=my.vector[6])
# 
# my.function(i=my.vector[7])
# 
# my.function(i=my.vector[8])
# 
# my.function(i=my.vector[9])
# 
# my.function(i=my.vector[10])
# 
# my.function(i=my.vector[10])









```
